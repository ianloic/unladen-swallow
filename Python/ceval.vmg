
\ VM instruction implementations

\ To compile this file with vmgen, find prims2x.fs in the gforth
\ distribution (often /usr/share/gforth/0.6.2/prims2x.fs) and replace
\ it with version 1.8 of the upstream source:
\ http://www.complang.tuwien.ac.at/viewcvs/cgi-bin/viewcvs.cgi/*checkout*/gforth/prims2x0.6.2.fs?rev=1.8
\ This increases the allowed number of stacks and allows instructions
\ like LOAD_FAST to be prefixes for superinstructions.  Later upstream
\ versions may work, but I haven't tested them.

\ _. Stack definitions &c.

\ stack inst-stream next_instr Cell
\E s" Oparg" single inst-stream type-prefix i
\E inst-stream stack-prefix #

\E stack data-stack stack_pointer Obj
\E : sp-access-transform ( itemnum -- index ) negate 1- ;
\E ' sp-access-transform ' data-stack >body stack-access-transform !
\E s" Obj" single data-stack type-prefix a


\E stack dummy-stack0 __none__ incref
\E dummy-stack0 stack-prefix inc:

\E stack dummy-stack1 __none__ decref
\E dummy-stack1 stack-prefix dec:

\E stack dummy-stack2 __none__ next
\E dummy-stack2 stack-prefix next:
\E s" __none__" single dummy-stack2 type-prefix next_opcode
\E s" __none__" single dummy-stack2 type-prefix on_error
\E s" __none__" single dummy-stack2 type-prefix fast_block_end
\E s" __none__" single dummy-stack2 type-prefix fast_yield
\E s" __none__" single dummy-stack2 type-prefix error


\E store-optimization on

\ _. Instructions

\ _ , Superinstruction Prefix Approved Opcodes (TM)
NOP ( -- )

LOAD_FAST ( #i -- a )
x = a = GETLOCAL(i);
if (a == NULL) {
        format_exc_check_arg(
                PyExc_UnboundLocalError,
                UNBOUNDLOCAL_ERROR_MSG,
                PyTuple_GetItem(co->co_varnames, i));
        why = WHY_EXCEPTION;
        /* On exception, make sure the stack is valid. */
        have_error = 1;
        INST_TAIL;
}
Py_INCREF(a);

LOAD_CONST ( #i -- a  inc:a )
x = a = GETITEM(consts, i);

STORE_FAST ( #i a -- )
SETLOCAL(i, a);

POP_TOP ( a -- dec:a )

ROT_TWO ( a1 a2 -- a2 a1 )

ROT_THREE ( a1 a2 a3 -- a3 a1 a2 )

ROT_FOUR ( a1 a2 a3 a4 -- a4 a1 a2 a3 )

DUP_TOP ( a -- a a  inc:a )

DUP_TOP_TWO ( a1 a2 -- a1 a2 a1 a2  inc:a1 inc:a2 )

DUP_TOP_THREE ( a1 a2 a3 -- a1 a2 a3 a1 a2 a3  inc:a1 inc:a2 inc:a3 )

\ _ , UNARY
UNARY_POSITIVE ( a1 -- a2   dec:a1  next:a2 )
a2 = PyNumber_Positive(a1);

UNARY_NEGATIVE ( a1 -- a2  dec:a1  next:a2 )
a2 = PyNumber_Negative(a1);

UNARY_NOT ( -- )
a1 = TOP();
err = PyObject_IsTrue(a1);
Py_DECREF(a1);
if (err == 0) {
        Py_INCREF(Py_True);
        SET_TOP(Py_True);
        NEXT();
} else if (err > 0) {
        Py_INCREF(Py_False);
        SET_TOP(Py_False);
        err = 0;
        NEXT();
}
STACKADJ(-1);
why = WHY_EXCEPTION;
ERROR();

UNARY_CONVERT ( a1 -- a2  dec:a1  next:a2 )
a2 = PyObject_Repr(a1);

UNARY_INVERT ( a1 -- a2  dec:a1  next:a2 )
a2 = PyNumber_Invert(a1);

\ _ , BINARY
BINARY_POWER ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_Power(a1, a2, Py_None);

BINARY_MULTIPLY ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_Multiply(a1, a2);

BINARY_DIVIDE ( a1 a2 -- a  dec:a1 dec:a2  next:a )
if (!_Py_QnewFlag)
        a = PyNumber_Divide(a1, a2);
else
        a = PyNumber_TrueDivide(a1, a2);

BINARY_TRUE_DIVIDE ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_TrueDivide(a1, a2);

BINARY_FLOOR_DIVIDE ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_FloorDivide(a1, a2);

BINARY_MODULO ( a1 a2 -- a  dec:a1 dec:a2  next:a )
if (PyString_CheckExact(a1))
	a = PyString_Format(a1, a2);
else
	a = PyNumber_Remainder(a1, a2);

BINARY_ADD ( a1 a2 -- a   next:a )
if (PyInt_CheckExact(a1) && PyInt_CheckExact(a2)) {
        /* INLINE: int + int */
        register long u, v, i;
        u = PyInt_AS_LONG(a1);
        v = PyInt_AS_LONG(a2);
        i = u + v;
        if ((i^u) < 0 && (i^v) < 0)
                a = PyNumber_Add(a1, a2);
        else
                a = PyInt_FromLong(i);
        Py_DECREF(a1);
} else if (PyString_CheckExact(a1) && PyString_CheckExact(a2)) {
        /* Look in the parallel PyInstructions object to find the
           symbolic opcode. */
        int opcode = PyInst_GET_OPCODE(
                &((PyInstructionsObject *)co->co_code)->inst[INSTR_OFFSET()]);
        a = string_concatenate(a1, a2, f, opcode, (next_instr+1)->oparg);
        /* string_concatenate consumed the ref to v */
} else {
        a = PyNumber_Add(a1, a2);
        Py_DECREF(a1);
}
Py_DECREF(a2);

BINARY_SUBTRACT ( a1 a2 -- a  dec:a1 dec:a2  next:a )
if (PyInt_CheckExact(a1) && PyInt_CheckExact(a2)) {
        /* INLINE: int - int */
        register long u, v, i;
        u = PyInt_AS_LONG(a1);
        v = PyInt_AS_LONG(a2);
        i = u - v;
        if ((i^u) < 0 && (i^~v) < 0)
                a = PyNumber_Subtract(a1, a2);
        else
                a = PyInt_FromLong(i);
} else
        a = PyNumber_Subtract(a1, a2);

BINARY_SUBSCR ( a1 a2 -- a  dec:a1 dec:a2  next:a )
if (PyList_CheckExact(a1) && PyInt_CheckExact(a2)) {
        /* INLINE: list[int] */
        Py_ssize_t i = PyInt_AsSsize_t(a2);
        if (i < 0)
                i += PyList_GET_SIZE(a1);
        if (i >= 0 && i < PyList_GET_SIZE(a1)) {
                a = PyList_GET_ITEM(a1, i);
                Py_INCREF(a);
        } else
                a = PyObject_GetItem(a1, a2);
} else
        a = PyObject_GetItem(a1, a2);

BINARY_LSHIFT ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_Lshift(a1, a2);

BINARY_RSHIFT ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_Rshift(a1, a2);

BINARY_AND ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_And(a1, a2);

BINARY_XOR ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_Xor(a1, a2);

BINARY_OR ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_Or(a1, a2);

\ _ , LIST_APPEND
LIST_APPEND ( a1 a2 -- dec:a1 dec:a2  next:error )
err = PyList_Append(a1, a2);

\ _ , INPLACE
INPLACE_POWER ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_InPlacePower(a1, a2, Py_None);

INPLACE_MULTIPLY ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_InPlaceMultiply(a1, a2);

INPLACE_DIVIDE ( a1 a2 -- a  dec:a1 dec:a2  next:a )
if (!_Py_QnewFlag)
        a = PyNumber_InPlaceDivide(a1, a2);
else
        a = PyNumber_InPlaceTrueDivide(a1, a2);

INPLACE_TRUE_DIVIDE ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_InPlaceTrueDivide(a1, a2);

INPLACE_FLOOR_DIVIDE ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_InPlaceFloorDivide(a1, a2);

INPLACE_MODULO ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_InPlaceRemainder(a1, a2);

INPLACE_ADD ( a1 a2 -- a   next:a )
if (PyInt_CheckExact(a1) && PyInt_CheckExact(a2)) {
        /* INLINE: int + int */
        register long u, v, i;
        u = PyInt_AS_LONG(a1);
        v = PyInt_AS_LONG(a2);
        i = u + v;
        if ((i^u) < 0 && (i^v) < 0)
                a = PyNumber_InPlaceAdd(a1, a2);
        else
                a = PyInt_FromLong(i);
        Py_DECREF(a1);
} else if (PyString_CheckExact(a1) && PyString_CheckExact(a2)) {
        /* Look in the parallel PyInstructions object to find the
           symbolic opcode. */
        int opcode = PyInst_GET_OPCODE(
                &((PyInstructionsObject *)co->co_code)->inst[INSTR_OFFSET()]);
        a = string_concatenate(a1, a2, f, opcode, (next_instr+1)->oparg);
        /* string_concatenate consumed the ref to v */
} else {
        a = PyNumber_InPlaceAdd(a1, a2);
        Py_DECREF(a1);
}
Py_DECREF(a2);

INPLACE_SUBTRACT ( a1 a2 -- a  dec:a1 dec:a2  next:a )
if (PyInt_CheckExact(a1) && PyInt_CheckExact(a2)) {
        /* INLINE: int - int */
        register long u, v, i;
        u = PyInt_AS_LONG(a1);
        v = PyInt_AS_LONG(a2);
        i = u - v;
        if ((i^u) < 0 && (i^~v) < 0)
                a = PyNumber_InPlaceSubtract(a1, a2);
        else
                a = PyInt_FromLong(i);
} else
        a = PyNumber_InPlaceSubtract(a1, a2);

INPLACE_LSHIFT ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_InPlaceLshift(a1, a2);

INPLACE_RSHIFT ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_InPlaceRshift(a1, a2);

INPLACE_AND ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_InPlaceAnd(a1, a2);

INPLACE_XOR ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_InPlaceXor(a1, a2);

INPLACE_OR ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PyNumber_InPlaceOr(a1, a2);

\ _ , SLICE
SLICE_NONE ( a1 -- a2  dec:a1  next:a2 )
a2 = apply_slice(a1, NULL, NULL);

SLICE_LEFT ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = apply_slice(a1, a2, NULL);

SLICE_RIGHT ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = apply_slice(a1, NULL, a2);

SLICE_BOTH ( a1 a2 a3 -- a  dec:a1 dec:a2 dec:a3  next:a )
a = apply_slice(a1, a2, a3);

STORE_SLICE_NONE ( a1 a2 -- dec:a1 dec:a2  next:error )
err = assign_slice(a2, NULL, NULL, a1);

STORE_SLICE_LEFT ( a1 a2 a3 -- dec:a1 dec:a2 dec:a3  next:error )
err = assign_slice(a2, a3, NULL, a1);

STORE_SLICE_RIGHT ( a1 a2 a3 -- dec:a1 dec:a2 dec:a3  next:error )
err = assign_slice(a2, NULL, a3, a1);

STORE_SLICE_BOTH ( a1 a2 a3 a4 -- dec:a1 dec:a2 dec:a3 dec:a4  next:error )
err = assign_slice(a2, a3, a4, a1); /* a2[a3:a4] = a1 */

DELETE_SLICE_NONE ( a1 -- dec:a1  next:error )
err = assign_slice(a1, NULL, NULL, (PyObject *) NULL);

DELETE_SLICE_LEFT ( a1 a2 -- dec:a1 dec:a2  next:error )
err = assign_slice(a1, a2, NULL, (PyObject *) NULL);

DELETE_SLICE_RIGHT ( a1 a2 -- dec:a1 dec:a2  next:error )
err = assign_slice(a1, NULL, a2, (PyObject *) NULL);

DELETE_SLICE_BOTH ( a1 a2 a3 -- dec:a1 dec:a2 dec:a3  next:error )
err = assign_slice(a1, a2, a3, (PyObject *) NULL); /* del a1[a2:a3] */

\ _ , SUBSCR
STORE_SUBSCR ( a1 a2 a3 -- dec:a1 dec:a2 dec:a3  next:error )
err = PyObject_SetItem(a2, a3, a1);

DELETE_SUBSCR ( a1 a2 -- dec:a1 dec:a2  next:error )
err = PyObject_DelItem(a1, a2);

\ _ , RAISE_VARARGS
RAISE_VARARGS_ZERO ( -- next:on_error )
why = do_raise(NULL, NULL, NULL);

RAISE_VARARGS_ONE ( a1 -- next:on_error )
why = do_raise(a1, NULL, NULL);

RAISE_VARARGS_TWO ( a1 a2 -- next:on_error )
why = do_raise(a1, a2, NULL);

RAISE_VARARGS_THREE ( a1 a2 a3 -- next:on_error )
why = do_raise(a1, a2, a3);

\ _ , LOAD
LOAD_NAME ( #i -- )
a2 = GETITEM(names, i);
if ((a1 = f->f_locals) == NULL) {
        PyErr_Format(PyExc_SystemError,
                     "no locals when loading %s",
                     PyObject_REPR(a2));
        why = WHY_EXCEPTION;
        ERROR();
}
if (PyDict_CheckExact(a1)) {
        x = PyDict_GetItem(a1, a2);
        Py_XINCREF(x);
} else {
        x = PyObject_GetItem(a1, a2);
        if (x == NULL && PyErr_Occurred()) {
                if (!PyErr_ExceptionMatches(PyExc_KeyError)) {
                        why = WHY_EXCEPTION;
                        ERROR();
                }
                PyErr_Clear();
        }
}
if (x == NULL) {
        x = PyDict_GetItem(f->f_globals, a2);
        if (x == NULL) {
                x = PyDict_GetItem(f->f_builtins, a2);
                if (x == NULL) {
                        format_exc_check_arg(PyExc_NameError, NAME_ERROR_MSG, a2);
                        why = WHY_EXCEPTION;
                        ERROR();
                }
        }
        Py_INCREF(x);
}
PUSH(x);
NEXT();

LOAD_GLOBAL ( #i -- )
a1 = GETITEM(names, i);
if (PyString_CheckExact(a1)) {
        /* Inline the PyDict_GetItem() calls.
	   WARNING: this is an extreme speed hack.
	   Do not try this at home. */
        long hash = ((PyStringObject *)a1)->ob_shash;
        if (hash != -1) {
                PyDictObject *d = (PyDictObject *)(f->f_globals);
                PyDictEntry  *e = d->ma_lookup(d, a1, hash);
                if (e == NULL) {
                        why = WHY_EXCEPTION;
                        ERROR();
                }
                x = e->me_value;
                if (x != NULL) {
                        Py_INCREF(x);
                        PUSH(x);
                        NEXT();
                }
                d = (PyDictObject *)(f->f_builtins);
                e = d->ma_lookup(d, a1, hash);
                if (e == NULL) {
                        why = WHY_EXCEPTION;
                        ERROR();
                }
                x = e->me_value;
                if (x != NULL) {
                        Py_INCREF(x);
                        PUSH(x);
                        NEXT();
                }
                goto load_global_error;
        }
}
/* This is the un-inlined version of the code above */
x = PyDict_GetItem(f->f_globals, a1);
if (x == NULL) {
        x = PyDict_GetItem(f->f_builtins, a1);
        if (x == NULL) {
        load_global_error:
                _PyEval_RaiseForGlobalNameError(a1);
                why = WHY_EXCEPTION;
                ERROR();
        }
}
Py_INCREF(x);
PUSH(x);
NEXT();

LOAD_CLOSURE ( #i -- a  inc:a  next:a )
a = freevars[i];

LOAD_DEREF ( #i -- )
x = freevars[i];
a2 = PyCell_Get(x);
if (a2 != NULL) {
        PUSH(a2);
        NEXT();
}
why = WHY_EXCEPTION;
/* Don't stomp existing exception */
if (PyErr_Occurred())
        ERROR();
if (i < PyTuple_GET_SIZE(co->co_cellvars)) {
        a1 = PyTuple_GET_ITEM(co->co_cellvars, i);
        format_exc_check_arg(
                PyExc_UnboundLocalError,
                UNBOUNDLOCAL_ERROR_MSG,
                a1);
} else {
        a1 = PyTuple_GET_ITEM(
                co->co_freevars,
                i - PyTuple_GET_SIZE(co->co_cellvars));
        format_exc_check_arg(
                PyExc_NameError,
                UNBOUNDFREE_ERROR_MSG,
                a1);
}
ERROR();

LOAD_ATTR ( #i a1 -- a3  dec:a1  next:a3 )
a2 = GETITEM(names, i);
a3 = PyObject_GetAttr(a1, a2);

\ _ , VALUE
RETURN_VALUE ( a -- next:fast_block_end )
retval = a;
why = WHY_RETURN;

YIELD_VALUE ( a -- next:fast_yield )
retval = a;
f->f_stacktop = stack_pointer;
why = WHY_YIELD;

\ _ , POP_BLOCK
POP_BLOCK ( -- next:next_opcode )
PyTryBlock *b = PyFrame_BlockPop(f);
while (STACK_LEVEL() > b->b_level) {
        a1 = POP();
        Py_DECREF(a1);
}

\ _ , END_FINALLY
END_FINALLY ( a1 -- next:on_error )
if (PyInt_Check(a1)) {
        why = (enum why_code) PyInt_AS_LONG(a1);
        assert(why != WHY_YIELD);
        if (why == WHY_RETURN || why == WHY_CONTINUE)
                retval = POP();
} else if (PyExceptionClass_Check(a1) || PyString_Check(a1)) {
        a2 = POP();
        a3 = POP();
        PyErr_Restore(a1, a2, a3);
        why = WHY_RERAISE;
        ERROR();
} else if (a1 != Py_None) {
        PyErr_SetString(PyExc_SystemError, "'finally' pops bad exception");
        why = WHY_EXCEPTION;
}
Py_DECREF(a1);

\ _ , BUILD
BUILD_TUPLE ( #i -- )
x = PyTuple_New(i);
if (x != NULL) {
        for (; --i >= 0;) {
                a1 = POP();
                PyTuple_SET_ITEM(x, i, a1);
        }
        PUSH(x);
        NEXT();
}
why = WHY_EXCEPTION;
ERROR();

BUILD_LIST ( #i -- )
x = PyList_New(i);
if (x != NULL) {
        for (; --i >= 0;) {
                a1 = POP();
                PyList_SET_ITEM(x, i, a1);
        }
        PUSH(x);
        NEXT();
}
why = WHY_EXCEPTION;
ERROR();

BUILD_MAP ( #i -- a  next:a )
a = _PyDict_NewPresized(i);

STORE_MAP ( a1 a2 a3 -- a1  dec:a2 dec:a3 next:error )
/* a1 == dict, a2 == value, a3 == key */
assert (PyDict_CheckExact(a1));
err = PyDict_SetItem(a1, a3, a2);  /* a1[a3] = a2 */

BUILD_SLICE_TWO ( a1 a2 -- a  dec:a1 dec:a2  next:a )
a = PySlice_New(a1, a2, NULL);

BUILD_SLICE_THREE ( a1 a2 a3 -- a  dec:a1 dec:a2 dec:a3  next:a )
a = PySlice_New(a1, a2, a3);

\ _ , STORE
STORE_NAME ( #i -- )
a2 = GETITEM(names, i);
a1 = POP();
if ((x = f->f_locals) != NULL) {
        if (PyDict_CheckExact(x))
                err = PyDict_SetItem(x, a2, a1);
        else
                err = PyObject_SetItem(x, a2, a1);
        Py_DECREF(a1);
        if (err == 0) NEXT();
        why = WHY_EXCEPTION;
        ERROR();
}
PyErr_Format(PyExc_SystemError,
             "no locals found when storing %s",
             PyObject_REPR(a2));
why = WHY_EXCEPTION;
ERROR();

STORE_ATTR ( #i a1 a2 -- dec:a1 dec:a2  next:error )
a3 = GETITEM(names, i);
err = PyObject_SetAttr(a2, a3, a1); /* a2.a3 = a1 */

STORE_GLOBAL ( #i a1 -- dec:a1  next:error )
a2 = GETITEM(names, i);
err = PyDict_SetItem(f->f_globals, a2, a1);

STORE_DEREF ( #i a -- dec:a  next:next_opcode )
x = freevars[i];
PyCell_Set(x, a);

\ _ , DELETE
DELETE_NAME ( #i -- )
a1 = GETITEM(names, i);
if ((x = f->f_locals) != NULL) {
        if ((err = PyObject_DelItem(x, a1)) != 0) {
                format_exc_check_arg(PyExc_NameError, NAME_ERROR_MSG, a1);
                why = WHY_EXCEPTION;
        }
        ERROR();
}
PyErr_Format(PyExc_SystemError,
             "no locals when deleting %s",
             PyObject_REPR(a1));
why = WHY_EXCEPTION;
ERROR();

DELETE_ATTR ( #i a1 -- dec:a1  next:on_error )
a2 = GETITEM(names, i);
if (0 != PyObject_SetAttr(a1, a2, (PyObject *) NULL) /* del a1.a2 */)
        why = WHY_EXCEPTION;

DELETE_GLOBAL ( #i -- next:on_error )
a1 = GETITEM(names, i);
if ((err = PyDict_DelItem(f->f_globals, a1)) != 0) {
        _PyEval_RaiseForGlobalNameError(a1);
        why = WHY_EXCEPTION;
}

DELETE_FAST ( #i -- )
x = GETLOCAL(i);
if (x != NULL) {
        SETLOCAL(i, NULL);
        NEXT();
}
format_exc_check_arg(
        PyExc_UnboundLocalError,
        UNBOUNDLOCAL_ERROR_MSG,
        PyTuple_GetItem(co->co_varnames, i));
why = WHY_EXCEPTION;
ERROR();

\ _ , UNPACK_SEQUENCE
UNPACK_SEQUENCE ( #i a1 -- )
if (PyTuple_CheckExact(a1) && PyTuple_GET_SIZE(a1) == i) {
        PyObject **items = ((PyTupleObject *)a1)->ob_item;
        while (i--) {
                a2 = items[i];
                Py_INCREF(a2);
                PUSH(a2);
        }
        Py_DECREF(a1);
        NEXT();
} else if (PyList_CheckExact(a1) && PyList_GET_SIZE(a1) == i) {
        PyObject **items = ((PyListObject *)a1)->ob_item;
        while (i--) {
                a2 = items[i];
                Py_INCREF(a2);
                PUSH(a2);
        }
} else if (unpack_iterable(a1, i, stack_pointer + i)) {
        stack_pointer += i;
} else {
        /* unpack_iterable() raised an exception */
        why = WHY_EXCEPTION;
}
Py_DECREF(a1);
ERROR();

\ _ , COMPARE_OP
COMPARE_OP ( #i a1 a2 -- a  dec:a1 dec:a2  next:a )
if (PyInt_CheckExact(a2) && PyInt_CheckExact(a1)) {
        /* INLINE: cmp(int, int) */
        register long u, v;
        register int res;
        u = PyInt_AS_LONG(a1);
        v = PyInt_AS_LONG(a2);
        switch (i) {
        case PyCmp_LT: res = u <  v; break;
        case PyCmp_LE: res = u <= v; break;
        case PyCmp_EQ: res = u == v; break;
        case PyCmp_NE: res = u != v; break;
        case PyCmp_GT: res = u >  v; break;
        case PyCmp_GE: res = u >= v; break;
        case PyCmp_IS: res = a1 == a2; break;
        case PyCmp_IS_NOT: res = a1 != a2; break;
        default: res = -1;
        }
        if (res < 0)
                a = cmp_outcome(i, a1, a2);
        else {
                a = res ? Py_True : Py_False;
                Py_INCREF(a);
        }
} else
        a = cmp_outcome(i, a1, a2);

\ _ , JUMP
JUMP_FORWARD ( #i -- )
JUMPBY(i);

POP_JUMP_IF_FALSE ( #i -- )
a1 = POP();
if (a1 == Py_True)
        ;
else if (a1 == Py_False)
        JUMPTO(i);
else {
        err = PyObject_IsTrue(a1);
        Py_DECREF(a1);
        if (err < 0) {
                why = WHY_EXCEPTION;
                ERROR();
        }
        else if (err == 0)
                JUMPTO(i);
        NEXT();
}
Py_DECREF(a1);

POP_JUMP_IF_TRUE ( #i -- )
a1 = POP();
if (a1 == Py_False)
        ;
else if (a1 == Py_True)
        JUMPTO(i);
else {
        err = PyObject_IsTrue(a1);
        Py_DECREF(a1);
        if (err < 0) {
                why = WHY_EXCEPTION;
                ERROR();
        }
        else if (err > 0)
                JUMPTO(i);
        NEXT();
}
Py_DECREF(a1);

JUMP_IF_FALSE_OR_POP ( #i -- )
a1 = TOP();
if (a1 == Py_True) {
        STACKADJ(-1);
        Py_DECREF(a1);
}
else if (a1 == Py_False)
        JUMPTO(i);
else {
        err = PyObject_IsTrue(a1);
        if (err < 0) {
                why = WHY_EXCEPTION;
                ERROR();
        }
        else if (err == 0)
                JUMPTO(i);
        else {
                STACKADJ(-1);
                Py_DECREF(a1);
        }
        NEXT();
}

JUMP_IF_TRUE_OR_POP ( #i -- )
a1 = TOP();
if (a1 == Py_False) {
        STACKADJ(-1);
        Py_DECREF(a1);
}
else if (a1 == Py_True)
        JUMPTO(i);
else {
        err = PyObject_IsTrue(a1);
        if (err < 0) {
                why = WHY_EXCEPTION;
                ERROR();
        }
        else if (err > 0)
                JUMPTO(i);
        else {
                STACKADJ(-1);
                Py_DECREF(a1);
        }
        NEXT();
}

JUMP_ABSOLUTE ( #i -- next:next_opcode )
JUMPTO(i);

\ _ , ITER
GET_ITER ( -- )
/* before: [obj]; after [getiter(obj)] */
a1 = TOP();
x = PyObject_GetIter(a1);
Py_DECREF(a1);
if (x != NULL) {
        SET_TOP(x);
        NEXT();
}
STACKADJ(-1);
why = WHY_EXCEPTION;
ERROR();

FOR_ITER ( #i -- )
/* before: [iter]; after: [iter, iter()] *or* [] */
a1 = TOP();
x = (*a1->ob_type->tp_iternext)(a1);
if (x != NULL) {
        PUSH(x);
        NEXT();
}
if (PyErr_Occurred()) {
        if (!PyErr_ExceptionMatches(PyExc_StopIteration)) {
                why = WHY_EXCEPTION;
                ERROR();
        }
        PyErr_Clear();
}
/* iterator ended normally */
a1 = POP();
Py_DECREF(a1);
JUMPBY(i);
NEXT();

\ _ , LOOP
BREAK_LOOP ( -- next:fast_block_end )
why = WHY_BREAK;

CONTINUE_LOOP ( #i -- )
retval = PyInt_FromLong(i);
if (!retval) {
        why = WHY_EXCEPTION;
        ERROR();
}
why = WHY_CONTINUE;
goto fast_block_end;

\ _ , SETUP
\ NOTE: If you add any new block-setup opcodes that are not try/except/finally
\ handlers, you may need to update the PyGen_NeedsFinalizing() function.

SETUP_LOOP ( #i -- next:next_opcode )
PyFrame_BlockSetup(f, SETUP_LOOP, INSTR_OFFSET() + i, STACK_LEVEL());

SETUP_EXCEPT ( #i -- next:next_opcode )
PyFrame_BlockSetup(f, SETUP_EXCEPT, INSTR_OFFSET() + i, STACK_LEVEL());

SETUP_FINALLY ( #i -- next:next_opcode )
PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + i, STACK_LEVEL());

\ _ , WITH_CLEANUP
WITH_CLEANUP ( -- )
{
        /* At the top of the stack are 1-3 values indicating
           how/why we entered the finally clause:
           - TOP = None
           - (TOP, SECOND) = (WHY_{RETURN,CONTINUE}), retval
           - TOP = WHY_*; no retval below it
           - (TOP, SECOND, THIRD) = exc_info()
           Below them is EXIT, the context.__exit__ bound method.
           In the last case, we must call
             EXIT(TOP, SECOND, THIRD)
           otherwise we must call
             EXIT(None, None, None)

           In all cases, we remove EXIT from the stack, leaving
           the rest in the same order.

           In addition, if the stack represents an exception,
           *and* the function call returns a 'true' value, we
           "zap" this information, to prevent END_FINALLY from
           re-raising the exception.  (But non-local gotos
           should still be resumed.)
        */

        PyObject *exit_func;

        a1 = POP();
        if (a1 == Py_None) {
                exit_func = TOP();
                SET_TOP(a1);
                a2 = a3 = Py_None;
        }
        else if (PyInt_Check(a1)) {
                switch(PyInt_AS_LONG(a1)) {
                case WHY_RETURN:
                case WHY_CONTINUE:
                        /* Retval in TOP. */
                        exit_func = SECOND();
                        SET_SECOND(TOP());
                        SET_TOP(a1);
                        break;
                default:
                        exit_func = TOP();
                        SET_TOP(a1);
                        break;
                }
                a1 = a2 = a3 = Py_None;
        }
        else {
                a2 = TOP();
                a3 = SECOND();
                exit_func = THIRD();
                SET_TOP(a1);
                SET_SECOND(a2);
                SET_THIRD(a3);
        }
        /* XXX Not the fastest way to call it... */
        x = PyObject_CallFunctionObjArgs(exit_func, a1, a2, a3,
                                         NULL);
        Py_DECREF(exit_func);
        if (x == NULL) {
                why = WHY_EXCEPTION;
                ERROR(); /* Go to error exit */
        }
        if (a1 != Py_None)
                err = PyObject_IsTrue(x);
        else
                err = 0;
        Py_DECREF(x);
        if (err < 0) {
                why = WHY_EXCEPTION;
                ERROR(); /* Go to error exit */
        }
        else if (err > 0) {
                /* There was an exception and a true return */
                STACKADJ(-2);
                Py_INCREF(Py_None);
                SET_TOP(Py_None);
                Py_DECREF(a1);
                Py_DECREF(a2);
                Py_DECREF(a3);
        } else {
                /* The stack was rearranged to remove EXIT
                   above. Let END_FINALLY do its thing */
        }
        ERROR();
}

\ _ , CALL_FUNCTION
CALL_FUNCTION ( #i -- )
PyObject **sp = stack_pointer;
#ifdef WITH_TSC
x = _PyEval_CallFunction(&sp, i, &intr0, &intr1)
#else
x = _PyEval_CallFunction(&sp, i);
#endif
stack_pointer = sp;
PUSH(x);
if (x != NULL) NEXT();
why = WHY_EXCEPTION;
ERROR();

CALL_FUNCTION_VAR_KW ( #i -- )
int var_kw = i & 0x0000FFFF;
int oparg  = i>>16;
int na     = oparg & 0xff;
int nk     = (oparg>>8) & 0xff;
int flags  = var_kw & 3;
int n      = na + 2 * nk;
PyObject **pfunc, *func, **sp;
if (flags & CALL_FLAG_VAR)
        n++;
if (flags & CALL_FLAG_KW)
        n++;
pfunc = stack_pointer - n - 1;
func  = *pfunc;
if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {
        PyObject *self = PyMethod_GET_SELF(func);
        Py_INCREF(self);
        func = PyMethod_GET_FUNCTION(func);
        Py_INCREF(func);
        Py_DECREF(*pfunc);
        *pfunc = self;
        na++;
        n++;
} else
        Py_INCREF(func);
sp = stack_pointer;
x = ext_do_call(func, &sp, flags, na, nk);
stack_pointer = sp;
Py_DECREF(func);
while (stack_pointer > pfunc) {
        a1 = POP();
        Py_DECREF(a1);
}
PUSH(x);
if (x != NULL) NEXT();
why = WHY_EXCEPTION;
ERROR();

\ _ , MAKE
MAKE_CLOSURE ( #i -- )
a1 = POP(); /* code object */
if ((x = PyFunction_New(a1, f->f_globals)) == NULL)
        why = WHY_EXCEPTION;
Py_DECREF(a1);
if (x != NULL) {
        a1 = POP();
        if (PyFunction_SetClosure(x, a1) != 0) {
                /* Can't happen unless bytecode is corrupt. */
                why = WHY_EXCEPTION;
        }
        Py_DECREF(a1);
}
if (x != NULL && i > 0) {
        a1 = PyTuple_New(i);
        if (a1 == NULL) {
                Py_DECREF(x);
                why = WHY_EXCEPTION;
                ERROR();
        }
        while (--i >= 0) {
                a2 = POP();
                PyTuple_SET_ITEM(a1, i, a2);
        }
        if (PyFunction_SetDefaults(x, a1) != 0) {
                /* Can't happen unless
                   PyFunction_SetDefaults changes. */
                why = WHY_EXCEPTION;
        }
        Py_DECREF(a1);
}
PUSH(x);
ERROR();

\ _. Superinstructions
CC = LOAD_CONST LOAD_CONST
CF = LOAD_CONST LOAD_FAST
FC = LOAD_FAST LOAD_CONST
FF = LOAD_FAST LOAD_FAST
FA = LOAD_FAST LOAD_ATTR

CBINARY_POWER = LOAD_CONST BINARY_POWER
CBINARY_MULTIPLY = LOAD_CONST BINARY_MULTIPLY
CBINARY_DIVIDE = LOAD_CONST BINARY_DIVIDE
CBINARY_TRUE_DIVIDE = LOAD_CONST BINARY_TRUE_DIVIDE
CBINARY_FLOOR_DIVIDE = LOAD_CONST BINARY_FLOOR_DIVIDE
CBINARY_MODULO = LOAD_CONST BINARY_MODULO
CBINARY_ADD = LOAD_CONST BINARY_ADD
CBINARY_SUBTRACT = LOAD_CONST BINARY_SUBTRACT
CBINARY_SUBSCR = LOAD_CONST BINARY_SUBSCR
CBINARY_LSHIFT = LOAD_CONST BINARY_LSHIFT
CBINARY_RSHIFT = LOAD_CONST BINARY_RSHIFT
CBINARY_AND = LOAD_CONST BINARY_AND
CBINARY_XOR = LOAD_CONST BINARY_XOR
CBINARY_OR = LOAD_CONST BINARY_OR
CLIST_APPEND = LOAD_CONST LIST_APPEND
CINPLACE_ADD = LOAD_CONST INPLACE_ADD
CINPLACE_SUBTRACT = LOAD_CONST INPLACE_SUBTRACT
CINPLACE_AND = LOAD_CONST INPLACE_AND
CSLICE_LEFT = LOAD_CONST SLICE_LEFT
CSLICE_RIGHT = LOAD_CONST SLICE_RIGHT
CDELETE_SUBSCR = LOAD_CONST DELETE_SUBSCR
CCOMPARE_OP = LOAD_CONST COMPARE_OP

STORE_LOAD_FAST = STORE_FAST LOAD_FAST
POP_LOAD_FAST = POP_TOP LOAD_FAST
C_CALL_FUNCTION = LOAD_CONST CALL_FUNCTION
F_CALL_FUNCTION = LOAD_FAST CALL_FUNCTION
CC_CALL_FUNCTION = LOAD_CONST LOAD_CONST CALL_FUNCTION
C_STORE_MAP = LOAD_CONST STORE_MAP
RETURN_CONST = LOAD_CONST RETURN_VALUE

\ Superinstructions that modify jumps. If you add one of these, you
\ have to fix up the peephole optimizer
POP_JUMP_ABSOLUTE = POP_TOP JUMP_ABSOLUTE
