#!/usr/bin/env perl
#
#                     The LLVM Compiler Infrastructure
#
# This file is distributed under the University of Illinois Open Source
# License. See LICENSE.TXT for details.
#
##===----------------------------------------------------------------------===##
#
#  A script designed to interpose between the build system and gcc.  It invokes
#  both gcc and the static analyzer.
#
##===----------------------------------------------------------------------===##

use strict;
use warnings;
use Cwd qw/ getcwd abs_path /;
use File::Temp qw/ tempfile /;
use File::Path qw / mkpath /;
use File::Basename;

my $CC = $ENV{'CCC_CC'};
if (!defined $CC) { $CC = "gcc"; }
my $CleanupFile;
my $ResultFile;

# Remove any stale files at exit.
END { 
  if (defined $CleanupFile && -z $CleanupFile) {
    `rm -f $CleanupFile`;
  }
}

##----------------------------------------------------------------------------##
#  Process Clang Crashes.
##----------------------------------------------------------------------------##

sub GetPPExt {
  my $Lang = shift;
  if ($Lang =~ /objective-c/) { return ".mi"; }
  return ".i";
}

my $ParserRejects = "Parser Rejects";

sub ProcessClangFailure {
  my ($Clang, $Lang, $file, $Args, $HtmlDir, $ErrorType, $ofile) = @_;
  my $Dir = "$HtmlDir/crashes";
  mkpath $Dir;
  
  my $prefix = "clang_crash";
  if ($ErrorType eq $ParserRejects) { $prefix = "clang_parser_rejects"; }

  # Generate the preprocessed file with cc (i.e., gcc).
  my ($PPH, $PPFile) = tempfile( $prefix . "_XXXXXX",
                                 SUFFIX => GetPPExt($Lang),
                                 DIR => $Dir);

  system $CC, @$Args, "-E", "-o", $PPFile;
  close ($PPH);

  # Generate the preprocessed file with clang.
  my $PPFile_Clang = $PPFile;
  $PPFile_Clang =~ s/[.](.+)$/.clang.$1/;  
  system $Clang, @$Args, "-E", "-o", "$PPFile_Clang";
  
  # Create the info file.
  open (OUT, ">", "$PPFile.info.txt") or die "Cannot open $PPFile.info.txt\n";
  print OUT abs_path($file), "\n";
  print OUT "$ErrorType\n";
  print OUT "@$Args\n";
  close OUT;
  `uname -a >> $PPFile.info.txt 2>&1`;
  `$CC -v >> $PPFile.info.txt 2>&1`;
  system 'mv',$ofile,"$PPFile.stderr.txt";
}

##----------------------------------------------------------------------------##
#  Running the analyzer.
##----------------------------------------------------------------------------##

sub Analyze {
  my ($Clang, $Args, $Lang, $Output, $Verbose, $HtmlDir, $file, $Analyses) = @_;

  # Skip anything related to C++.
  return if ($Lang =~ /c[+][+]/);

  my $RunAnalyzer = 0;
  my $Cmd;
  my @CmdArgs;
  my @CmdArgsSansAnalyses;
  
  if ($Lang =~ /header/) {
    exit 0 if (!defined ($Output));
    $Cmd = 'cp';
    push @CmdArgs,$file;
    # Remove the PCH extension.
    $Output =~ s/[.]gch$//;
    push @CmdArgs,$Output;
    @CmdArgsSansAnalyses = @CmdArgs;    
  }
  else {
    $Cmd = $Clang;
    push @CmdArgs,'-DIBOutlet=__attribute__((iboutlet))';
    push @CmdArgs,@$Args;
    @CmdArgsSansAnalyses = @CmdArgs;
    push @CmdArgs,'--analyze';
    push @CmdArgs,"--analyzer-display-progress";
    push @CmdArgs,(split /\s/,$Analyses);
    $RunAnalyzer = 1;
  }
  
  my @PrintArgs;
  my $dir;
  
  if ($Verbose) {
    $dir = getcwd();
    print STDERR "\n[LOCATION]: $dir\n";
    push @PrintArgs,"'$Cmd'";
    foreach my $arg (@CmdArgs) { push @PrintArgs,"\'$arg\'"; }
  }
  
  if ($Verbose == 1) {
    # We MUST print to stderr.  Some clients use the stdout output of
    # gcc for various purposes. 
    print STDERR join(' ',@PrintArgs);
    print STDERR "\n";
  }
  elsif ($Verbose == 2) {
    print STDERR "#SHELL (cd '$dir' && @PrintArgs)\n";
  }
  
  if ($RunAnalyzer) {
    if (defined $ResultFile) {
      push @CmdArgs,'-o';
      push @CmdArgs, $ResultFile;
    }
    elsif (defined $HtmlDir) {
      push @CmdArgs,'-o';
      push @CmdArgs, $HtmlDir;
    }
  }
  
  if (defined $ENV{'CCC_UBI'}) {   
    push @CmdArgs,"--analyzer-viz-egraph-ubigraph";
  }

  # Capture the STDERR of clang and send it to a temporary file.
  # Capture the STDOUT of clang and reroute it to ccc-analyzer's STDERR.
  # We save the output file in the 'crashes' directory if clang encounters
  # any problems with the file.  
  pipe (FROM_CHILD, TO_PARENT);
  my $pid = fork();
  if ($pid == 0) {
    close FROM_CHILD;
    open(STDOUT,">&", \*TO_PARENT);
    open(STDERR,">&", \*TO_PARENT);
    exec $Cmd, @CmdArgs;
  }
  
  close TO_PARENT;
  my ($ofh, $ofile) = tempfile("clang_output_XXXXXX", DIR => $HtmlDir);
  
  while (<FROM_CHILD>) {
    print $ofh $_;
    print STDERR $_;    
  }

  waitpid($pid,0);
  my $Result = $?;

  # Did the command die because of a signal?
  if ($Result & 127 and $Cmd eq $Clang and defined $HtmlDir) {
    ProcessClangFailure($Clang, $Lang, $file, \@CmdArgsSansAnalyses, $HtmlDir,
                        "Crash", $ofile);
  }
  elsif ($Result) {
    ProcessClangFailure($Clang, $Lang, $file, \@CmdArgsSansAnalyses, $HtmlDir,
                        $ParserRejects, $ofile);
  }
  
  `rm -f $ofile`;
}

##----------------------------------------------------------------------------##
#  Lookup tables.
##----------------------------------------------------------------------------##

my %CompileOptionMap = (
  '-nostdinc' => 0,
  '-fblocks' => 0,
  '-fobjc-gc-only' => 0,
  '-fobjc-gc' => 0,  
  '-include' => 1,
  '-idirafter' => 1,
  '-iprefix' => 1,
  '-iquote' => 1,
  '-isystem' => 1,
  '-iwithprefix' => 1,
  '-iwithprefixbefore' => 1
);

my %LinkerOptionMap = (
  '-framework' => 1
);

my %CompilerLinkerOptionMap = (
  '-isysroot' => 1,
  '-arch' => 1,
  '-v' => 0,
  '-fpascal-strings' => 0,
  '-mmacosx-version-min' => 0 # This is really a 1 argument, but always has '='
);

my %IgnoredOptionMap = (
  '-MT' => 1,  # Ignore these preprocessor options.
  '-MF' => 1,

  '-fsyntax-only' => 0,
  '-save-temps' => 0,
  '-install_name' => 1,
  '-exported_symbols_list' => 1,
  '-current_version' => 1,
  '-compatibility_version' => 1,
  '-init' => 1,
  '-e' => 1,
  '-seg1addr' => 1,
  '-bundle_loader' => 1,
  '-multiply_defined' => 1,
  '-sectorder' => 3,
  '--param' => 1,
  '-u' => 1
);

my %LangMap = (
  'c'   => 'c',
  'cpp' => 'c++',
  'cc'  => 'c++',
  'i'   => 'c-cpp-output',
  'm'   => 'objective-c',
  'mi'  => 'objective-c-cpp-output'
);

my %UniqueOptions = (
  '-isysroot' => 0  
);

##----------------------------------------------------------------------------##
#  Main Logic.
##----------------------------------------------------------------------------##

my $Action = 'link';
my @CompileOpts;
my @LinkOpts;
my @Files;
my $Lang;
my $Output;
my %Uniqued;

# Forward arguments to gcc.
my $Status = system($CC,@ARGV);
if ($Status) { exit($Status >> 8); }

# Get the analysis options.
my $Analyses = $ENV{'CCC_ANALYZER_ANALYSIS'};
if (!defined($Analyses)) { $Analyses = '-checker-cfref'; }

# Get the store model.
my $StoreModel = $ENV{'CCC_ANALYZER_STORE_MODEL'};

# Get the output format.
my $OutputFormat = $ENV{'CCC_ANALYZER_OUTPUT_FORMAT'};

# Determine the level of verbosity.
my $Verbose = 0;
if (defined $ENV{CCC_ANALYZER_VERBOSE}) { $Verbose = 1; }
if (defined $ENV{CCC_ANALYZER_LOG}) { $Verbose = 2; }

# Determine what clang executable to use.
my $Clang = $ENV{'CLANG'};
if (!defined $Clang) { $Clang = 'clang'; }

# Get the HTML output directory.
my $HtmlDir = $ENV{'CCC_ANALYZER_HTML'};

my %ArchsSeen;

# Process the arguments.
foreach (my $i = 0; $i < scalar(@ARGV); ++$i) {
  my $Arg = $ARGV[$i];  
  my ($ArgKey) = split /=/,$Arg,2;

  # Modes ccc-analyzer supports
  if ($Arg eq '-E') { $Action = 'preprocess'; }
  elsif ($Arg eq '-c') { $Action = 'compile'; }
  elsif ($Arg =~ /^-print-prog-name/) { exit 0; }

  # Specially handle duplicate cases of -arch
  if ($Arg eq "-arch") {
    my $arch = $ARGV[$i+1];
    $ArchsSeen{$arch} = 1;
    ++$i;
    next;
  }

  # Options with possible arguments that should pass through to compiler.
  if (defined $CompileOptionMap{$ArgKey}) {
    my $Cnt = $CompileOptionMap{$ArgKey};
    push @CompileOpts,$Arg;
    while ($Cnt > 0) { ++$i; --$Cnt; push @CompileOpts, $ARGV[$i]; }
    next;
  }

  # Options with possible arguments that should pass through to linker.
  if (defined $LinkerOptionMap{$ArgKey}) {
    my $Cnt = $LinkerOptionMap{$ArgKey};
    push @LinkOpts,$Arg;
    while ($Cnt > 0) { ++$i; --$Cnt; push @LinkOpts, $ARGV[$i]; }
    next;
  }

  # Options with possible arguments that should pass through to both compiler
  # and the linker.
  if (defined $CompilerLinkerOptionMap{$ArgKey}) {
    my $Cnt = $CompilerLinkerOptionMap{$ArgKey};
    
    # Check if this is an option that should have a unique value, and if so
    # determine if the value was checked before.
    if ($UniqueOptions{$Arg}) {
      if (defined $Uniqued{$Arg}) {
        $i += $Cnt;
        next;
      }
      $Uniqued{$Arg} = 1;
    }
    
    push @CompileOpts,$Arg;    
    push @LinkOpts,$Arg;

    while ($Cnt > 0) {
      ++$i; --$Cnt;
      push @CompileOpts, $ARGV[$i];
      push @LinkOpts, $ARGV[$i];
    }
    next;
  }
  
  # Ignored options.
  if (defined $IgnoredOptionMap{$ArgKey}) {
    my $Cnt = $IgnoredOptionMap{$ArgKey};
    while ($Cnt > 0) {
      ++$i; --$Cnt;
    }
    next;
  }
  
  # Compile mode flags.
  if ($Arg =~ /^-[D,I,U](.*)$/) {
    my $Tmp = $Arg;    
    if ($1 eq '') {
      # FIXME: Check if we are going off the end.
      ++$i;
      $Tmp = $Arg . $ARGV[$i];
    }
    push @CompileOpts,$Tmp;
    next;
  }
  
  # Language.
  if ($Arg eq '-x') {
    $Lang = $ARGV[$i+1];
    ++$i; next;
  }

  # Output file.
  if ($Arg eq '-o') {
    ++$i;
    $Output = $ARGV[$i];
    next;
  }
  
  # Get the link mode.
  if ($Arg =~ /^-[l,L,O]/) {
    if ($Arg eq '-O') { push @LinkOpts,'-O1'; }
    elsif ($Arg eq '-Os') { push @LinkOpts,'-O2'; }
    else { push @LinkOpts,$Arg; }
    next;
  }
  
  if ($Arg =~ /^-std=/) {
    push @CompileOpts,$Arg;
    next;
  }
  
#  if ($Arg =~ /^-f/) {
#    # FIXME: Not sure if the remaining -fxxxx options have no arguments.
#    push @CompileOpts,$Arg;
#    push @LinkOpts,$Arg;  # FIXME: Not sure if these are link opts.
#  }
  
  # Get the compiler/link mode.
  if ($Arg =~ /^-F(.+)$/) {
    my $Tmp = $Arg;
    if ($1 eq '') {
      # FIXME: Check if we are going off the end.
      ++$i;
      $Tmp = $Arg . $ARGV[$i];
    }
    push @CompileOpts,$Tmp;
    push @LinkOpts,$Tmp;
    next;
  }

  # Input files.
  if ($Arg eq '-filelist') {
    # FIXME: Make sure we aren't walking off the end.
    open(IN, $ARGV[$i+1]);
    while (<IN>) { s/\015?\012//; push @Files,$_; }
    close(IN);
    ++$i; next;
  }
  
  if (!($Arg =~ /^-/)) {
    push @Files,$Arg; next;
  }
}

if ($Action eq 'compile' or $Action eq 'link') {
  foreach my $file (@Files) {
    # Determine the language for the file.
    my $FileLang = $Lang;

    if (!defined($FileLang)) {
      # Infer the language from the extension.
      if ($file =~ /[.]([^.]+)$/) {
        $FileLang = $LangMap{$1};
      }
    }
    
    next if (!defined $FileLang);
    
    my @AnalyzeArgs;
    
    if ($FileLang ne 'unknown') {
      push @AnalyzeArgs,'-x';
      push @AnalyzeArgs,$FileLang;
    }

    if (defined $StoreModel) {
      push @AnalyzeArgs, $StoreModel;
    }
    
    if (defined $OutputFormat) {
      push @AnalyzeArgs, "-analyzer-output-" . $OutputFormat;
      if ($OutputFormat eq "plist") {
        # Change "Output" to be a file.
        my ($h, $f) = tempfile("report-XXXXXX", SUFFIX => ".plist",
                               DIR => $HtmlDir);
        $ResultFile = $f;
        $CleanupFile = $f;
      }
      
    }

    push @AnalyzeArgs,@CompileOpts;
    push @AnalyzeArgs,$file;

    my @Archs = keys %ArchsSeen;
    if (scalar @Archs) {
      foreach my $arch (@Archs) {
        my @NewArgs;
        push @NewArgs, '-arch';
        push @NewArgs, $arch;
        push @NewArgs, @AnalyzeArgs;
        Analyze($Clang, \@NewArgs, $FileLang, $Output,
                $Verbose, $HtmlDir, $file, $Analyses);
      }
    }
    else {
      Analyze($Clang, \@AnalyzeArgs, $FileLang, $Output,
              $Verbose, $HtmlDir, $file, $Analyses);
    }
  }
}

exit($Status >> 8);

